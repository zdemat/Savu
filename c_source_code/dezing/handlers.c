/*$Id: handlers.c 347 2014-05-21 15:15:57Z kny48981 $*/
#   define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <setjmp.h>

#ifdef GNU_TRAP_FPE
#   define _GNU_SOURCE
#   include <fenv.h>
extern int feenableexcept (int excepts);
#endif
int the_signo;

/*
   extern int jflg;
   extern jmp_buf env;
   extern int signal_change_freq;
*/

//extern int errno;

void float_error (int signo)
{                               /* signal handler for sigfpe */
  static int count = 0;

  printf ("\nSignal handler: float_error: ERROR: fpe detected (signal %i) !!!!\n", signo);
  if (count == 0)
  #ifdef JUNK
    printf ("\nRaising USR2 to obtain output step.\n");
  raise (SIGUSR2);
  #endif
  count++;
  if (count >= 10){
    printf ("\n%s: More than %i fpe errors detected. Exiting...\n", __func__,count);
    exit (60);
  }
  /* RE_RAISE the signal so that the OS can handle it properly */
  /* and return to the program while de-bugging so you can actually find the mistake */
  signal (SIGFPE, float_error);
  return;
}

void catchit (int signo)
{                               /* signal handler */
  printf ("\n%s: Signal %d received \n",__func__, signo);
  printf ("attempting to flush files ... \n");
  the_signo = signo;
  fflush (NULL);
  sync();
  //FILE *fp;
  //struct stat status;

  /******** handle the TERM signal *************/
  if (signo == SIGTERM){
   printf("%s: got SIGTERM\n",__func__);
   printf ("attempting to close files ... \n");
   fcloseall();
   sync();
   printf ("exiting ... \n");
   exit(199);

  /******** handle the USR1 signal *************/
  } else if (signo == SIGUSR1) {
   /* jflg = JFLG_WRITEXIT; */
   printf("%s: got SIGUSR1\n",__func__);
   /* basically do nothing */


  /******** handle the USR2 signal *************/
  }else if (signo == SIGUSR2) {
   /*  jflg = JFLG_WRITEBIN; */
    printf("%s: got SIGUSR2\n",__func__);
    signal (SIGUSR2, catchit);

    /********************************************************/
    /* mechanism for changing output timestep while runnign */
    /* if the file is there, then it gets read when the signal */
    /* is caught */

    #ifdef JUNK
    /* here's how I used to use SIGUSR2 to trigger the program */
    /* to read some changed parameters */
    if (stat ("umat_newstep.in", &status) == 0) {
      char *line, *sep, *token;
      line = (char *) calloc (MAX_STRING_LEN, sizeof (char));
      sep = (char *) calloc (MAX_STRING_LEN, sizeof (char));
      sprintf (sep, " ,;\t\n\r");
      fprintf (stderr, "%s: Changing the output step as requested.\n", __func__);

      /* change the time step */
      fp = fopen ("umat_newstep.in", "r");

      while (fgets (line, MAX_STRING_LEN, fp) != NULL) {
        /* ignore comment and blank lines */
        if (line[0] == '%' || line[0] == '#' || (token = strtok (line, sep)) == NULL) {
          continue;
        } else if (strcasecmp (token, "NewStep") == 0) {
          if ((token = strtok (NULL, sep)) != NULL)
            signal_change_freq = atoi (token);
          if (signal_change_freq <= 0) {
            signal_change_freq = 0;
          }
        } else {
          signal_change_freq = 0;
        }
      }
    } else {
      /* no change */
      signal_change_freq = 0;
      fprintf (stderr, "%s:Returning with output flag set.\n", __func__);
    }
    return;
  #endif /*JUNK*/
  }else{
     fprintf(stderr,"Signal %i not handled. Resetting... \n",signo);
     signal (signo, catchit);
  }
  //longjmp (env, 1);
  return;
}

#ifdef GNU_TRAP_FPE
void enable_fpe_traps ()
{
  /*
   * This installs the SIGFPE signal handler and enables traps for
   *
   * debugging purposes.
   */

  fenv_t env;
  int excepts;

  /* Enable exception trapping. */

  excepts = FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW;
  feholdexcept (&env);          /* start clean */
  if (feenableexcept (excepts) == -1) /* set traps */
  /* crash out if the traps can't even be set! */
    exit (1);  
}
#endif

/***************************************************/
/* rcs id routine to include rcs id in the program */
/* generated by make_rcs_sub.sh script             */
/***************************************************/
char const *handlers_c ()
{
  static char const rcsid[] = "$Id: handlers.c 347 2014-05-21 15:15:57Z kny48981 $";

  return (rcsid);
}
